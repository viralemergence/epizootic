#' Interpolation of Missing Timesteps in a Raster Stack
#'
#' Interpolates missing time points in a raster stack with layers for different time points. Intended
#' for `terra::SpatRaster` use only.
#'
#' @importFrom terra rast approximate xmin xmax ymin ymax crs res values<-
#' @import purrr
#' @param raster_stack A `terra::SpatRaster` with at least two layers.
#' @param source_time A numeric vector indicating the timesteps of the `raster_stack`, whatever those
#' may be, e.g., `c(1940, 1945)`.
#' @param target_time A numeric vector indicating the series of timesteps desired in the output, e.g.,
#' `c(1940, 1941, 1942. 1943, 1944, 1945)`.
#' @param time_label `terra::SpatRaster`s do not allow raw numbers as names of raster layers. Therefore
#' a string is needed to place before the timestep number, e.g., "BP", "BCE".
#' @param ... Does nothing. A placeholder for future code improvements.
#' @param method Interpolation method passed on to `terra::approximate`. Default is "linear";
#' alternative is "constant", which implements a step function.
#' @return A `terra::SpatRaster` with as many layers as the length of `target_time`.
#' @export
interpolate_raster <- function(raster_stack, source_time, target_time, time_label, ...,
                               method = "linear") {
  if (!inherits(raster_stack, "SpatRaster")) {
    stop("raster_stack must be a terra::SpatRaster")
  }
  if (!all(is.numeric(source_time), is.numeric(target_time))) {
    stop("source time and target time must be numeric vectors")
  }
  if (length(target_time) < length(source_time)) {
    stop("Target time vector must be longer than source time vector
         \n (otherwise there's no interpolation)")
  }
  if (!is.character(time_label)) {
    stop("time_label must be a string")
  }
  template <- raster_stack[[1]]
  # Create output raster stack
  outputStack <- rast(nlyrs = length(target_time), nrows = nrow(template),
                      ncols = ncol(template),
                      xmin = xmin(template), xmax = xmax(template), ymin = ymin(template),
                      ymax = ymax(template), crs = crs(template), resolution = res(template),
                      vals = NA, names = target_time %>% map_chr(~paste0(time_label, .)))
  for (i in seq_along(source_time)) {
    j <- which(target_time == source_time[i])
    time <- target_time[j]
    inSeq <- which(source_time == time)
    if (length(inSeq) != 0) {
      r <- raster_stack[[inSeq]]
      values(outputStack[[j]]) <- r[]
    }
  }
  # urbanStack <- setZ(urbanStack, z = ts, name = "Years BP")
  interpolated_urban <- approximate(outputStack, method = method)
  return(interpolated_urban)
}

#' Prep Inputs for Aspatial SIRI Model Functions
#'
#' This function converts the data frames generated by the Latin hypercube sampling of my prior
#' distributions into appropriate inputs for the `siri_model_summer`, `siri_model_winter`, and
#' `siri_model_year` functions.
#'
#' @param df A single row of a data frame generated by `simulation_input_df`.
#' @param init Represents the state of the population at the start of the simulation.
#' A list with named elements, each one a numeric of length 1:
#' \describe{
#'     \item{\code{Sj}}{Susceptible juveniles.}
#'     \item{\code{Sa}}{Susceptible adults.}
#'     \item{\code{I1j}}{Juveniles infected for the first time.}
#'     \item{\code{I1a}}{Adults infected for the first time.}
#'     \item{\code{Rj}}{Recovered juveniles.}
#'     \item{\code{Ra}}{Recovered adults.}
#'     \item{\code{I2j}}{Juveniles infected for the second+ time.}
#'     \item{\code{I2a}}{Adults infected for the second+ time.}
#' }
#' @param f A string indicating whether inputs are being prepped for the `siri_model_summer`,
#' `siri_model_winter`, or `siri_model_year` function.
#' @param ... A placeholder for future code improvements.
#' @return A named list of all arguments needed for the selected function. Can be passed directly to that
#' function using `purrr::lift`.
#' @export

aspatial_siri_prep <- function(df, init, f = c("siri_model_summer", "siri_model_winter",
                                               "siri_model_year"),
                               ...) {
  if (f == "siri_model_summer" | f == "siri_model_year") {
    summer_params <- c(
      season_length <- df$summer_length,
      birth = df$birth,
      beta_Sj = df$beta_Sa_summer * df$Sj_multiplier,
      beta_Sa = df$beta_Sa_summer,
      mortality_Sj = df$mortality_Sj_summer,
      mortality_Sa = 0,
      mortality_I1j = df$mortality_I1j_summer,
      mortality_I1a = df$mortality_I1a_summer,
      mortality_I2j = (df$mortality_I1j_summer * df$mortality_I2_modifier),
      mortality_I2a = (df$mortality_I1a_summer * df$mortality_I2_modifier),
      carrying_capacity = 5000,
      recovery_I1 = df$recovery_I1,
      recovery_I2 = df$recovery_I2,
      beta_Rj = df$beta_Sa_summer * df$Sj_multiplier * df$beta_I2_modifier,
      beta_Ra = df$beta_Sa_summer * df$beta_I2_modifier
    )
  }
  if (f == "siri_model_winter" | f == "siri_model_year") {
    winter_params <- c(
      season_length <- 363 - df$summer_length,
      beta_Sj = df$beta_Sa_winter*df$Sj_multiplier,
      beta_Sa = df$beta_Sa_winter,
      mortality_Sj = df$mortality_Sj_winter,
      mortality_Sa = df$mortality_Sa_winter,
      mortality_I1j = df$mortality_I1j_winter,
      mortality_I1a = df$mortality_I1a_winter,
      mortality_I2j = (df$mortality_I1j_winter * df$mortality_I2_modifier),
      mortality_I2a = (df$mortality_I1a_winter * df$mortality_I2_modifier),
      carrying_capacity = 5000,
      recovery_I1 = df$recovery_I1,
      recovery_I2 = df$recovery_I2,
      beta_Rj = df$beta_Sa_winter * df$Sj_multiplier * df$beta_I2_modifier,
      beta_Ra = df$beta_Sa_winter * df$beta_I2_modifier
    )
  }
  if (f == "siri_model_year") {
    return(
      list(
        initial_vector = init,
        summer_params = summer_params,
        winter_params = winter_params
      )
    )
  }
  if (f == "siri_model_summer") {
    return(
      list(
        initial_vector = init,
        parms = summer_params
      )
    )
  }
  if (f == "siri_model_winter") {
    return(
      list(
        initial_vector = init,
        parms = winter_params
      )
    )
  }
}
